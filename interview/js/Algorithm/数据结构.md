## TypeScript

## 栈
栈是一种遵从后进先出(LIFO)原则的有序集合  
```js
class Stack{
    constructor(){
        this.tiems = [];
    }
    push(element){
        this.items.push(element)
    }
    pop(){
        return this.items.pop()
    }
    peek(){
        return this.items[this.items.length-1]
    }
    isEmpty(){
        return this.items.length === 0
    }
    size(){
        return this.items.length
    }
    clear(){
        this.items = []
    }
}
// 私有属性
const items = new WeakMap();
class Stack{
    constructor(){
        items.set(this,[])
    }
    push(element){
        const s = items.get(this);
        s.push(element)
    }
}
```
## 队列
队列是遵循先进先出(FIFO)原则的一组有序的项  
```js
class Queue{
    constructor(){
        this.count = 0;
        this.lowestCount = 0;
        this.items = {};
    }
    enqueue(element){
        this.items[this.count] = element;
        this.count++;
    }
    dequeue(){
        if(this.isEmpty){
            return undefined;
        }
        const result = this.items[this.lowestCount];
        delete this.items[this.lowestCount];
        this.lowestCount++;
        return result;
    }
    peek(){
        if(this.isEmpty()){
            return undefined;
        }
        return this.items[this.lowestCount];
    }
    isEmpty(){
        return this.count - this.lowestCount === 0;
    }
    size(){
        return this.count - this.lowestCount;
    }
    clear(){
        this.items = {};
        this.count = 0;
        this.lowestCount = 0;
    }
    toString(){
        if(this.isEmpty()){
            return ''
        }
        let objString = `${this.items[this.lowestCount]}`;
        for(let i = this.lowestCount+1;i<this.count;i++){
            objString = `${objString},${this.items[i]}`
        }
        return obgjString;
    }
}
```
## 双端队列
双端队列允许我们同时从前端和后端添加和移除元素的特殊队列  
```js
class Deque{
    constructor(){
        this.count = 0;
        this.lowestCount = 0;
        this.items = {};
    }
    addFront(element){
        if(this.isEmpty()){
            this.addBack(element);
        }else if(this.lowestCoun > 0){
            this.lowestCount--;
            this.items[this.lowestCount] = element;
        }else{
            for(let i = this.count;i > 0;i--){
                this.items[i] = this.items[i-1];
            }
            this.count++;
            this.lowestCount = 0;
            this.items[0] = element;
        }
    }
    addBack(element){
        this.items[this.count] = element;
        this.count++;
    }
    removeFront(){

    }
    removeBack(){

    }
    peekFront(){

    }
    peekBack(){

    }
}
```
## 循环队列
```js
// 击鼓传花
function hotPotato(elementList,num){
    const queue = new Queue();
    const elimitatedList = [];
    for(let i = 0;i < elementList.length;i++){
        queue.enqueue(elementList[i]);
    }
    while(queue.size()>1){
        for(let i = 0;i < num;i++){
            queue.enqueue(queue.dequeue());
        }
        elimitatedList.push(queue.dequeue())
    }
    return {
        eliminated:elimitatedList,
        winner:queue.dequeue();
    }
}
```
## 链表
链表存储有序的元素集合,每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成  
```js
function LinkedList(){
    let node = function(element){
        this.element = element;
        this.next = null;
    }
    let length = 0;
    let head = null;
    this.append = function(element){
        let node = new Node(element),
            current;
        if(head === null){
            head = node;
        }else{
            current = head;
        }
        while(current.next){
            current = current.next;
        }
        current.next = node;
    };
    this.insert = function(position,element){
        if(position >=0 && positon <= length){
            let node = new Node(element),
                current = head,
                previous,
                index = 0;
            if(position === 0){
                node.next = current;
                head = node;
            }else{
                while(index++ < position){
                    previous = current;
                    current = current.next;
                }
                previous.next = node;
                node.next = current;
            }
            length++;
            return true;
        }else{
            return false;
        }
    };
    this.removeAt = function(position){
        if(position > -1 && position < length){
            let current = head,
                previous,
                index = 0;
            if(position === 0){
                head = current.next;
            }else{
                while(indexx++ < position){
                    previous = current;
                    current = curent.next;
                }
                previous.next = current.next;
            }
            length--;
            return current.element;
        }else
        return null;
    }
    this.remove = function(element){
        let index = this.indexOf(element);
        return this.removeAt(index);
    }
    this.indexOf = function(element){
        let current = head,
            index = -1;
        while(current){
            index++;
            if(element === current.element){
                return index;
            }
            current = current.next;
        }
        return -1;
    }
    this.isEmpty = function(){
        return length === 0;
    }
    this.size = function(){
        return length;
    }
    this.getHead = function(){
        return head;
    }
    this.toString = function(){}
    this.print = function(){}
}
```
## 双向链表
在双向链表中,链接是双向的,一个链向下一个元素,另一个链向前一个元素  
```js
function DoublyLinkedList(){
    let Node = function(element){
        this.element = elemen;
        this.next = null;
        this.prev  null;
    };
    let length = 0;
    let head = null;
    let tail = null;
    this.insert = function(position,element){
        if(position >= 0 && postion <= length){
            let node = new Node(element),
                current = head,
                previous,
                index = 0;
            if(position === 0){
                if(!head){
                    head = node;
                    tail = node;
                }else{
                    node.next = current;
                    current.prev = node;
                    head = node;
                }
            }else if(position === length){
                current = tail;
                current.next = node;
                node.prev = current;
                tail = node;
            }else{
                while(index++ < length){
                    previous = current;
                    current = current.next;
                }
                previous.next = node;
                node.prev = previous;
                node.next = current;
                current.prev = node;
            }
            length++;
            return true;
        }else{
            return false;
        }
    }
    this.removeAt = function(position){
        if(postion > -1 && position < length){
            let current = head,
                previous,
                index = 0;
            if(position === 0){
                head = current.next;
                if(length === 1){
                    tail = null;
                }else{
                    head.prev = null;
                }
            }else if(position === length-1){
                current = tail;
                tail = current.prev;
                tail.next = null;
            }else{
                while(index++ < position){
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;
                current.next.prev = previous;
            }
            length--;
            return current.element;
        }else{
            return null;
        }
    }
}
```
## 循环链表
循环链表的最后一个元素指向下一个元素的指针指向第一个元素`head`  
## 双向循环链表
有指向`head`元素的`tail.next`和指向`tail`元素的`head.prev`  
## 集合(Set)
集合是由一组无序且唯一的项组成的  
```js
class Set{
    constructor(){
        this.items = {};
    }
    has(element){
        return element in items;
    }
    add(element){
        if(!this.has(element)){
            this.items[element] = element;
            return true;
        }
        return false;
    }
    delete(element){
        if(this.has(element)){
            delete this.items[element];
            return true;
        }
        return false;
    }
    clear(){
        this.items = {};
    }
    size(){
        return Object.keys(this.items).length;
    }
    values(){
        return Object.values(this.items);
    }
    union(otherSet){ //并集
        const unionSet = new Set();
        this.values().forEach(value => unionSet.add(value));
        otherSet.values().forEach(value => unionSet.add(value));
        return unionSet;
    }
    intersection(otherSet) { //交集
        const intersectionSet = new Set();
        const values = this.values();
        const otherValues = otherSet.values();
        let biggerSet = values;
        let smallerSet = otherValues;
        if (otherValues.length - values.length > 0) {
            biggerSet = otherValues; 
            smallerSet = values; 
        } 
        smallerSet.forEach(value => {
            if (biggerSet.includes(value)) { 
                intersectionSet.add(value); 
            } 
        }); 
        return intersectionSet; 
    }
    difference(otherSet) { //差集
        const differenceSet = new Set();
        this.values().forEach(value => {
            if (!otherSet.has(value)) {
                differenceSet.add(value);
            } 
        }); 
        return differenceSet; 
    }
    isSubsetOf(otherSet) { //子集
        if (this.size() > otherSet.size()) {
            return false; 
        } 
        let isSubset = true;
        this.values().every(value => {
            if (!otherSet.has(value)) {
                isSubset = false;
                return false; 
            } 
            return true;
        }); 
        return isSubset;
    }
}
```
## 字典(Map)

## 递归
###### 递归阶乘
```js
function factor(n){
    if(n===1 || n===0){
        return 1;
    }
    return n*factor(n-1);
}
```
###### 斐波那契数列
- 位置0的斐波那契数是0  
- 位置1和2的斐波那契数是1  
- n(n>2)的斐波那契数是(n-1)的斐波那契数加上(n-2)的斐波那契数  
```js
// 迭代
function fibonacci(n){
    if(n<1) return 0;
    if(n<=2) return 1;
    let fibN2 = 0,
        fibN1 = 1,
        fibN = n;
    for(let i = 2;i <=n;i++){
        fibN = fibN1 + fibN2;
        fibN1 = fibN;
        fibN2 = fibN1;
    }
    return fibN;
}
// 递归
function fibonacci(n){
    if(n<1) return 0;
    if(n<=2) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
// 记忆化斐波那契数
function fibonacciMemoization(n) { 
    const memo = [0, 1]; // {1} 
    const fibonacci = (n) => { 
    if (memo[n] != null) return memo[n]; // {2} 
        return memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo); // {3} 
    }; 
    return fibonacci; 
}
```
## 树
树是一种分层数据的抽象模型  
- 位于数顶部的节点叫做根节点,它没有父节点  
- 节点分为内部节点和外部节点  
- 至少有一个子节点的节点称为内部节点,没有子元素的节点称为外部节点或叶节点  
###### 树的遍历  
- 中序遍历  
`左子树->根节点->右子树`  
- 先序遍历  
`根节点->左子树->右子树`  
- 后序遍历  
`左子树->右子树->根节点`  
###### 二叉树和二叉搜索树
- 二叉树中的节点最多只能有两个子节点  
- 二叉搜索树(BST)只允许左侧节点存储比父节点小的值,右侧存储比父节点大的值  
```js
class Node{
    constructor(key){
        this.key = key;
        this.left = null;
        this.right = null;
    }
}
class BinarySerchTree{
    constructor(){
        this.root = null;
    }
    insert(key){
        let newNode = new Node(key);
        if(this.root == null){
            this.root = newNode;
        }else{
            this.insertNode(this.root,newNode);
        }
    }
    insertNode(root,newNode){
        if(newNode.key < root.key){
            (!root.left) ? root.left = newNode : this.insertNode(root.left,newNode) ;
        }else{
            (!root.right) ? root.right = newNode : this.insertNode(root.right,newNode) ;
        }
    }
    removeNode(root,key){
        if(vkey < root.key){
            root.left = this.removeNode(root.left,value);
            return root;
        }else if(key > root.key){
            root.right = this.reomvoeNode(root.right,value);
            return root;
        }else{
            // 没有左右节点
            if(!root.left && !root.right){
                root = null;
                return root;
            }
            // 只存在左节点或右节点
            if(root.left == null){
                root = root.right;
                return root;
            }else if(root.right == null){
                root = root.left;
                return root;
            }
            // 左右节点都存在
            let minRight = this.findMinNode(root.right);
            root.key = minRight.key;
            root.right = this.removeNode(root.right,minRight.key);
            return root;
        }
    }
    remove(key){
        if(!this.root){
            return 'Tree is Empty'
        }else{
            this.removeNode(this.root,key)
        }
    }
    findMinNode(root){
        if(!root.left){
            return root;
        }else{
            return this.findMinNode(root.left);
        }
    }
    findMaxNode(root){
        if(!root.right){
            return root;
        }else{
            return this.findMaxNode(root.right);
        }
    }
    searchNode(root,key){
        if(!root) return null;
        if(key < root.key){
            return this.searchNode(root.left,key)
        }else if(key > root.key){
            return this.searchNode(root.right,value)
        }
        return root;
    }
    search(key){
        if(!this.root){
            return 'Tree is Empty';
        }else{
            return Boolean(this.searchNode(this.root,key))
        }
    }
}
```
## 排序算法
###### 冒泡排序
- 比较所有相邻的两个项,如果第一个比第二个大,则交换它们  
```js
function bubbleSort(arr){
    for(let i = 0;i < arr.length;i++){
        for(let j = 0;j < arr.length-1-i;j++){
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
            }
        }
    }
}
```
###### 选择排序
- 选择第一个,依次比较,最小的放第一个,接着从第二个开始
```js
selectSort(arr) {
    let len = arr.length;
    for (let outer = 0; outer < len - 1; outer++) {
        for (let inner = outer; inner < len; inner++) {
            if (arr[outer] > arr[inner]) {
                [arr[outer], arr[inner]] = [arr[inner], arr[outer]]
            }
        }
    }
    return arr;
}
```
###### 插入排序
- 分批排列数组项
```js
insertSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i; j > 0; j--) {
            if (arr[j] < arr[j - 1]) {
                [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
            } else {
                break;
            }
        }
    }
    return arr;
}
```
###### 归并排序
- 归并排序室一宗分而治之算法,将原数组切分成较小的数组,直到每个小数组只有一个位置,接着将小数组合并成大数组,直到之后只有一个排序完成的大数组  
```js
function mergeSort(arr){
    if(arr.length > 1){
        let length = arr.length;
        let middle = Math.floor(length/2);
        let left = mergeSort(arr.slice(0,middle));
        let right = mergeSort(arr.slice(middle,length));
        arr = merge(left,right);
    }
    return arr;
}
function merge(left,right){
    let i = 0;
    let j = 0;
    const result = [];
    while(i < left.length && j < right.length){
        result.push(left[i]<right[i] ? left[i++] : right[j++])
    }
    return result.concat(i<left.length ? left.slice(i) : right.slice(j) )
}
```




